##README

Question list_calcGrade.cpp
while 문과 연산자 cin으로 임의의 양만큼 입력을 받을 때, enter로 인한 줄바꿈을 인식해 while문을 종료시킬 수 있나.

-------------------------------------------------------------------------------------------

New grammar
#1
조건문 간결하게 쓰는 방식
(변수) = (조건) ? (결과1) : (결과2);

=>
if(조건) (변수) = (결과1);
else (변수) = (결과2);
	
#2
#include <algorithm>
#include <functional>

vector<type> x;
sort(x.begin(), x.end(), greater<type>()); -> 내림 차순 정렬


#3
#include <algorithm>
#include <vector>

vector<int> s = {3, 1, 1, 2, 3};
sort(s.begin(), s.end());

s.erase(unique(s.begin(), s.end()), s.end());
-> s = {1, 2, 3}

/*unique(s.begin(), s.end());
-> s = {1, 2, 3, 1, 3};

#4
#include <stdexcept>

if(오류 발생 조건) throw domain_error("오류 원인");
//throw 함수 확인 필요



-------------------------------------------------------------------------------------------

simple tips
#1
string과 vector 라이브러리 중 size()의 경우 string과 vector의 실제 길이를 나타내므로 반복문 등의 index에
넣을 때에는 주의할 것.

#2
vector의 경우 변수 뒤에 [index]를 입력해 해당 위치의 원소를 가져올 수 있지만, string의 경우 string 라이브
러리에 내장되어있는 .at(index) 함수를 사용해야 원소를 가져올 수 있다.

#3
참조를 쓰는 이유는 기존의 인수를 복사하지 않고 해당 인수에 직접 접근하여 참조 매개변수의 변화가 기존의 인수에도 
영향을 미치도록 하기 위한 것이고, const는 프로그램이 매개변수를 변경시키지 않도록 하는 역할을 한다. 따라서 
함수가 호출하는 매개변수가 벡터나 문자열 처럼 복사하는데 시간이 오래 걸리는 경우 참조를 사용하게 되면 코드의
연산 시간이 줄어들게 되며, 추가적으로 해당 함수에서 매개변수에 변동사항이 없는 경우 const를 사용하는 것이
더욱 효율적이라는 의미이다.

#4
rvalue는 일시적인 객체라고 생각하면 된다. 예를 들어 두 int 타입 인수 a와 b에 대한 연산 a/b의 결과는 rvalue가
되는 것이고, 이 연산값을 새로운 int 타입 객체 c에 대입하여 c = a/b가 된다면 이 결과값 c는 비일시적 객체 lvalue가
된다. 추가적으로 const가 아닌 일반적인 참조의 경우 함수 내에서의 해당 매개변수의 변화가 호출받은 인수의 변화로
이어지기 때문에 해당 매개변수는 반드시 lvalue를 호출한 값이여야 한다. 
(추가: vector의 경우 내부에 아무 원소도 들어이있지 않는 비어있는 벡터의 경우 lvalue가 아닌 것으로 취급 된다.
다만 이 경우의 벡터가 rvalue에 포함되는 객체인지는 추가적인 확인이 필요하다.)

#5
컨테이너 내부의 요소들에 순차적으로 접근해야하는 경우, index 대신 반복자(iterator)을 사용하게 되면 라이브러리에서 
해당 접근이 순차적으로 이루어진다는 것을 인식한다. 즉 어떠한 컨테이너에서 오로지 순차적인 접근 방식만을 이용해 
값을 호출해야하는 경우 반복자를 사용하면 보다 효율적으로 값을 호출할 수 있다는 것이다. 반면 이 상황에서 index를 이용해
값을 호출할 경우, index의 특성 상 index 값의 변화가 순차적인 접근으로 이어지는지 확인하기 위한 추가적인 연산이 필요하기
때문에 효율이 떨어진다.
+ 단순한 iterator은 index와 같이 해당 요소를 가리키는 역할을 한다. 이 때 iterator이 가리키는 요소의 값 자체를 
호출하기 위해 사용하는 것이 역참조 연산자(*)이다. 즉, 역참조 연산자를 사용해 *iterator을 호출하게 될 경우 컨테이너 요소의
값 자체에 접근하여 연산을 진행한다고 생각하면 된다.

#6
벡터의 erase 함수의 경우 대입하는 인수의 타입이 index가 아니라 iterator이다. 그런데 *iterator을 이용해 호출한
값을 erase 함수로 제거할 경우, 해당 위치 뒤에 있는 모든 요소들의 반복자들은 무효가 된다.(추가. vector 대신 list 타입을
사용할 경우 제거된 요소 외의 모든 요소들의 반복자는 그대로 유효하다.) 즉, erase 를 사용한 위치 이후로는 반복자의 사용이 
제한되는 것이다. 이를 방지하기 위해 erase 함수는 요소를 제거한 후 순서상 해당 요소 바로 다음의 요소를 가리키는 반복자를 
반환한다. 따라서 iterator = vector.erase(iterator); 와 같은 형태로 코드를 작성하게 되면 iterator이 가리키는
위치의 요소가 삭제되고 iterator은 바로 다음 요소를 가리키게 되는 것이다.

#7
벡터 컨테이너에서는 요소의 삽입, 제거는 자칫 잘못 사용할 경우 데이터 처리 속도를 기하급수적으로 늘리는 원인이 될 수 있다.
하지만 이러한 요소의 삽입, 제거는 매우 빈번하게 일어날 수 있는 작업이기 때문에, C++ 라이브러리에서는 이러한 작업의 효율성을
높이기 위해 list 타입을 제공한다. (타입 자체의 복잡도는 vector 보다 list가 더 높기 때문에 요소의 삽입, 제거가 아닌 단순한
순차적 접근을 지원하는 코드의 경우 list 타입의 실행 속도가 더 느리다.) 

-------------------------------------------------------------------------------------------

Check again!

beautifulString.cpp
H_index.cpp
Tiling.cpp
triangleSnail.cpp
scoville.cpp
binaryChange.cpp(10진수 -> 2진수 변환 시 값이 큰 10진수를 2진수로 변경할 때 2진수의 용량이 long long 타입이 허용한 용량을 초과하는 문제)


-------------------------------------------------------------------------------------------

Question!
#1
Accelerated C++ 책 내용을 보면 지속적으로 함수의 인수로써 istream 타입의 매개변수를 사용하는 것을 확인할 수 있다. 
이렇게 함수의 인수에 입력을 위한 매개변수를 추가하는 것이 보다 효율적인 건지, 아니면 저자의 코딩 습관인지 확인 필요.

#2
오버로드가 뭐지?


-------------------------------------------------------------------------------------------

#2021.03.04
Ubuntu 설치. 현재 인터넷 연결 문제로 인해 사용 중지 및 문제 확인 중.

#2021.03.06
무선 네트워크 연결 완료. 이더넷 연결 문제 진행 중.
멀티 부팅 grub 설정 완료. 스피커 음성 송출 오류 발생.

#2021.03.08
우분투 상에 깃 설치.

#2021.03.12
우분투에 OpenCV 오픈소스 설치.

#2021.03.14
우분투 이더넷 카드 인식 문제 확인.